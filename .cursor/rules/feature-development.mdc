# Feature Development Guidelines using Riverpod

## Overview

Each new feature should follow the clean architecture structure, integrated with **Riverpod** for state management and dependency injection.

---

## 1. Feature Directory Structure

lib/features/feature_name/
â”œâ”€â”€ data/
â”‚ â”œâ”€â”€ datasources/
â”‚ â”‚ â””â”€â”€ feature_remote_data_source.dart
â”‚ â””â”€â”€ repositories/
â”‚ â””â”€â”€ feature_repository_impl.dart
â”œâ”€â”€ domain/
â”‚ â”œâ”€â”€ entities/
â”‚ â”‚ â””â”€â”€ feature_entity.dart
â”‚ â”œâ”€â”€ repositories/
â”‚ â”‚ â””â”€â”€ feature_repository.dart
â”‚ â””â”€â”€ usecases/
â”‚ â”œâ”€â”€ get_feature_usecase.dart
â”‚ â””â”€â”€ create_feature_usecase.dart
â”œâ”€â”€ application/
â”‚ â””â”€â”€ feature_notifier.dart
â”œâ”€â”€ presentation/
â”‚ â”œâ”€â”€ pages/
â”‚ â”‚ â””â”€â”€ feature_screen.dart
â”‚ â””â”€â”€ widgets/
â”‚ â””â”€â”€ feature_widget.dart
â””â”€â”€ feature_providers.dart

markdown
Copy
Edit

---

## 2. Implementation Steps

### ğŸ“¦ Domain Layer
- Define business logic:
  - `entities/`: Define feature models.
  - `repositories/`: Abstract interfaces.
  - `usecases/`: Core feature logic (`GetFeatureUseCase`, `CreateFeatureUseCase`).

### ğŸ—ƒï¸ Data Layer
- Define external APIs and local access:
  - `datasources/`: Remote and local API logic.
  - `repositories/`: Implement domain contracts using datasources.

### ğŸ“² Application Layer
- Use `StateNotifier` or `AsyncNotifier`:
  - Place `feature_notifier.dart` inside `application/` folder.
  - Manage logic and state transitions using Riverpod.

### ğŸ¨ Presentation Layer
- Build UI components:
  - `pages/`: Main screens.
  - `widgets/`: Reusable components.

### ğŸ§© Dependency Injection
- Register providers in `feature_providers.dart`.
- This includes:
  - DataSourceProvider
  - RepositoryProvider
  - UseCaseProviders
  - NotifierProvider

---

## 3. Notifier Implementation (Instead of BLoC)

```dart
// application/feature_notifier.dart
final featureNotifierProvider = StateNotifierProvider<FeatureNotifier, FeatureState>((ref) {
  return FeatureNotifier(
    getFeatureUseCase: ref.watch(getFeatureUseCaseProvider),
    createFeatureUseCase: ref.watch(createFeatureUseCaseProvider),
  );
});

class FeatureNotifier extends StateNotifier<FeatureState> {
  final GetFeatureUseCase _getFeatureUseCase;
  final CreateFeatureUseCase _createFeatureUseCase;

  FeatureNotifier({
    required GetFeatureUseCase getFeatureUseCase,
    required CreateFeatureUseCase createFeatureUseCase,
  })  : _getFeatureUseCase = getFeatureUseCase,
        _createFeatureUseCase = createFeatureUseCase,
        super(FeatureInitial());

  Future<void> loadFeature() async {
    state = FeatureLoading();
    final result = await _getFeatureUseCase();
    state = result.fold(
      (failure) => FeatureError(message: failure.message),
      (data) => FeatureLoaded(data),
    );
  }
}
4. Provider Registration Example
dart
Copy
Edit
// feature_providers.dart

final featureRemoteDataSourceProvider = Provider<FeatureRemoteDataSource>((ref) {
  return FeatureRemoteDataSourceImpl(dio: ref.watch(dioProvider));
});

final featureRepositoryProvider = Provider<FeatureRepository>((ref) {
  return FeatureRepositoryImpl(remoteDataSource: ref.watch(featureRemoteDataSourceProvider));
});

final getFeatureUseCaseProvider = Provider<GetFeatureUseCase>((ref) {
  return GetFeatureUseCase(repository: ref.watch(featureRepositoryProvider));
});

final createFeatureUseCaseProvider = Provider<CreateFeatureUseCase>((ref) {
  return CreateFeatureUseCase(repository: ref.watch(featureRepositoryProvider));
});
5. Testing Strategy
âœ… Use ProviderContainer to override dependencies:

dart
Copy
Edit
final container = ProviderContainer(overrides: [
  featureRepositoryProvider.overrideWithValue(MockFeatureRepository()),
]);

final useCase = container.read(getFeatureUseCaseProvider);
âœ… Write unit tests for:

Use cases

Repository implementations

StateNotifiers (with expectLater)

UI widgets (with flutter_test)

6. Navigation Integration
Add route constants in AppRoutes class

Use GoRouter for navigation

Navigate using:

dart
Copy
Edit
context.go(AppRoutes.featureScreen);
7. Common Patterns
Error Handling
dart
Copy
Edit
Future<Either<Failure, Success>> call() async {
  try {
    return Right(await repository.fetch());
  } catch (e) {
    return Left(ServerFailure(message: e.toString()));
  }
}
State Classes
dart
Copy
Edit
sealed class FeatureState {}

class FeatureInitial extends FeatureState {}
class FeatureLoading extends FeatureState {}
class FeatureLoaded extends FeatureState {
  final List<FeatureEntity> data;
  FeatureLoaded(this.data);
}
class FeatureError extends FeatureState {
  final String message;
  FeatureError({required this.message});
}
Best Practices
Use Provider for stateless dependencies (like repositories/usecases)

Use StateNotifier or AsyncNotifier for stateful logic

Separate concerns: one file per responsibility

Register all feature-specific providers in feature_providers.dart

Handle loading, success, and error states cleanly

Override providers in tests for unit-level granularity

Use ProviderScope at app entry point

description: Riverpod-based feature development structure, patterns, and rules
globs:
alwaysApply: false