# Flutter Coding Standards (Riverpod + Clean Architecture)

## 📁 File Organization
- Use a **feature-based folder structure**
- Each feature lives under `lib/features/feature_name/`
- Follow clean architecture:
  - `data/` → remote/local sources and models
  - `domain/` → entities, use cases, repositories
  - `application/` → state management (`StateNotifier`, `AsyncNotifier`)
  - `presentation/` → UI pages, widgets

## 📛 Naming Conventions
- **Files**: `snake_case` (e.g., `auth_notifier.dart`, `user_repository.dart`)
- **Classes**: `PascalCase` (e.g., `AuthNotifier`, `UserRepository`)
- **Variables/Functions**: `camelCase` (e.g., `userName`, `getUserData()`)
- **Constants**: `SCREAMING_SNAKE_CASE` (e.g., `API_BASE_URL`)

## 🔁 Riverpod State Management Guidelines
- Use `StateNotifier` or `AsyncNotifier` for managing state
- Define a separate state class if managing multiple UI states (loading, error, etc.)
- Group related providers in `feature_providers.dart`
- Keep `StateNotifier` logic clean and side-effect free
- Prefer `AsyncNotifier` for fully async workflows

## 🧱 Widget Guidelines
- Prefer `StatelessWidget` when no internal state is needed
- Always use `const` constructors where possible
- Extract reusable UI into `widgets/` folder
- Widget names must clearly reflect purpose and context

## ⚠️ Error Handling
- Use `Either<Failure, Success>` from `dartz` in use cases
- Define feature-specific `Failure` classes (e.g., `ServerFailure`, `CacheFailure`)
- Handle loading, success, and error states explicitly in state classes and UI
- Avoid throwing exceptions from use cases — return failures instead

## 💉 Dependency Injection with Riverpod
- Register all external and feature dependencies using `Provider` and `StateNotifierProvider` in `*_providers.dart`
- Use `Provider` for stateless classes (e.g., use cases, repositories)
- Use `StateNotifierProvider` or `AsyncNotifierProvider` for state management
- Keep each feature's providers isolated to avoid tight coupling

## 🧪 Testing
- Write **unit tests** for use cases and repositories
- Write **notifier tests** using `ProviderContainer` with overridden providers
- Write **widget tests** for UI behavior
- Use `mocktail` or `mockito` for mocking
- Clean up `ProviderContainer` with `.dispose()` in `tearDown()`

## 🎯 Code Style
- Follow the official [Flutter style guide](https://dart.dev/guides/language/effective-dart/style)
- Use `flutter_lints` or `very_good_analysis`
- Keep methods **short and focused** (ideally < 20 lines)
- Use **clear and descriptive** variable and method names
- Add **comments** only for complex business rules or exceptions to convention

---

## ✅ Example State Class
```dart
sealed class AuthState {}

class AuthInitial extends AuthState {}
class AuthLoading extends AuthState {}
class AuthAuthenticated extends AuthState {
  final User user;
  AuthAuthenticated(this.user);
}
class AuthError extends AuthState {
  final String message;
  AuthError(this.message);
}
✅ Example Provider Setup
dart
Copy
Edit
final authNotifierProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  return AuthNotifier(
    loginUseCase: ref.watch(loginUseCaseProvider),
  );
});
description: Flutter clean architecture and Riverpod-based coding standards
globs:
alwaysApply: false